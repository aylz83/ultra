#! /usr/bin/env python

import os
import sys

import itertools
import argparse
import errno
import math


import gffutils

# from collections import deque


from modules import create_splice_graph as splice_graph
from modules import mummer_wrapper 

def construct_graph(args):
    fn = gffutils.example_filename(args.gff)
    db = gffutils.create_db(fn, dbfn='test.db', force=True, keep_order=True, merge_strategy='merge', sort_attribute_values=True)
    db = gffutils.FeatureDB('test.db', keep_order=True)

    gene_graphs, topological_sorts = splice_graph.create_graph(db)
    refs_sequences = splice_graph.get_sequences_from_choordinates(gene_graphs, args.ref)
    
    dump to pickle here! Both graph and reference seqs

def align_reads(args)
    
    mummer_wrapper.find_mems(args.refs, args.reads)
    # non_redundant_segments = splice_graph.collapse_identical_for_mumer(exon_db)

    # exon_db = parse_tsv()
    # graph = create_graph()
    # graph_top_sorted_order = top_sort_graph()
    # hits = run_mummer(non_redundant_segments, reads )
    # for read_hits in hits:
    #     chain_hits_read()



if __name__ == '__main__':

    parser = argparse.ArgumentParser(description="torkel -- Classify long reads based on transcript graphs")
    subparsers = parser.add_subparsers(help='Subcommands for eaither constructing a graph, or align reads')
    # parser.add_argument("-v", help='Different subcommands for eaither constructing a graph, or align reads')

    construct_graph_parser = subparsers.add_parser('construct', help= "Construct a splicing graph")
    align_reads_parser = subparsers.add_parser('align', help="Classify and align reads with colinear chaining to DAGs")

    construct_graph_parser.add_argument('gff', type=str, help='Path to gff or gtf file with gene models.')
    construct_graph_parser.add_argument('ref', type=str, help='Reference genome (fasta)')
    construct_graph_parser.add_argument('--outfile', type=str, help='Path to fasta file with a nucleotide sequence (e.g., gene locus) to simulate isoforms from.')
    construct_graph_parser.add_argument('--pickle', action='store_true', help='Store the graph on file.')
    construct_graph_parser.set_defaults(which='construct_graph')


    align_reads_parser.add_argument('graph', type=str, help='Path to fasta file with a nucleotide sequence (e.g., gene locus) to simulate isoforms from.')    
    align_reads_parser.add_argument('refs', type=str, help='Path to fasta file with a nucleotide sequence (e.g., gene locus) to simulate isoforms from.')    
    align_reads_parser.add_argument('reads', type=str, help='Path to fasta file with a nucleotide sequence (e.g., gene locus) to simulate isoforms from.')
    align_reads_parser.set_defaults(which='align_reads')

    args = parser.parse_args()


    if len(sys.argv)==1:
        parser.print_help()
        sys.exit()

    if args.which == 'construct_graph':

        construct_graph(args)
    elif args.which == 'align_reads':
        align_reads(args)
    else:
        print('invalid call')
