

"""
    snakemake --keep-going -j 999999 --cluster "sbatch --exclude={cluster.exclude} --mem {cluster.mem} -c {cluster.cpus-per-task} -N {cluster.Nodes}  -t {cluster.runtime} -J {cluster.jobname} --mail-type={cluster.mail_type} --mail-user={cluster.mail}" --cluster-config cluster.json --configfile experiments.json --latency-wait 100 --verbose -n

    
    # BIOLOGICAL

    # Subsample reads from original data


    # running isONclust/isONclust2
    1. going from original reads to clusters
    2. from cluster file to fastq files


    ### Running isONcorrect
    1. From cluster fasta to corrected reads
    2. Merge all corrected read clusters

    ### Run evaluation looking for read error rate againse reference (and eventually splice site classification)

    # SIMULATED

    ### simulation evalautions
    4. Basing exon correction plot with error rate

    5. Join everything to table


    # target rules:

"""

shell.prefix("set -o pipefail; ")
# configfile: "experiments.json"

wildcard_constraints:
    nr_reads="[\d]+",

####################################################
########## standard python functions ###############
####################################################

import re
import os
import errno
import shutil
import glob



def mkdir_p(path):
    print("creating", path)
    try:
        os.makedirs(path)
    except OSError as exc:  # Python >2.5
        if exc.errno == errno.EEXIST and os.path.isdir(path):
            pass
        else:
            raise

rule all:
   input:  config["ROOT_OUT"] + "/evaluation/ont_human/results_per_read.csv",
            config["ROOT_OUT"] + "/evaluation/simulated/results_per_read.csv",
            config["ROOT_OUT"] + "/evaluation/simulated_nic/results_per_read.csv"


rule biological:
    input: config["ROOT_OUT"] + "/eval_table.csv"


rule simulation:
    input: config["ROOT_OUT"] + "/eval_sim_table.csv"


rule controlled_sim:
    input:  config["ROOT_OUT"] + "/controlled.csv"


rule simulate:
    input:  fasta = config["TRANSCRIPTOME"],
            gtf_annotation = config["ANNOTATION"] + "/NA12878.gtf",
            ref = config["HG38"]
    output: simulated_reads =  config["ROOT_OUT"] + "/data/{dataset}/reads.fa",
            accessions_map =  config["ROOT_OUT"] + "/data/{dataset}/accessions_map.csv"
    run:

        inbase= config["ROOT_IN"]
        mkdir_p(config["ROOT_OUT"] + "/data/")
        
        if wildcards.dataset == "simulated":
            shell("python {inbase}/evaluation/simulate_reads.py {input.fasta} {output.simulated_reads} 1000000 --fasta")

        elif wildcards.dataset == "simulated_nic":
            shell("python {inbase}/evaluation/simulate_reads.py --nic --gtf {input.gtf_annotation} {input.ref} {output.simulated_reads} 1000000 --fasta")

        # shell("python {inbase}/evaluation/simulate_reads.py {input.fasta} {output.simulated_reads} 1000000 --fasta")



rule ultra_prep:
    input:  fastq =  config["ROOT_OUT"] + "/data/{dataset}.fa",
            ref = config["HG38"],
            gtf_annotation = config["ANNOTATION"] + "/NA12878.gtf"

    output: ref_index = config["ROOT_OUT"] + "/alignments/ultra/{dataset}/all_splice_sites_annotations.pickle",
            # time_and_mem =  config["ROOT_OUT"] + "/time_and_mem/ultra/{dataset}/indexing_time_and_mem.txt"
    run:
        outfolder = config["ROOT_OUT"] + "/alignments/ultra/{0}/".format(wildcards.dataset)
        mkdir_p(outfolder)
        time_outfolder = config["ROOT_OUT"] + "/time_and_mem/ultra/{0}/".format(wildcards.dataset)
        mkdir_p(time_outfolder)

        shell("/usr/bin/time -v /galaxy/home/ksahlin/prefix/source/torkel/torkel2 prep_splicing --disable_infer {input.gtf_annotation} {outfolder}")
        shell("/usr/bin/time -v /galaxy/home/ksahlin/prefix/source/torkel/torkel2 prep_seqs {input.ref} {outfolder} --min_mem 14 --mask_threshold 100 2>&1 | tee {output.time_and_mem}") #2> {output.time_and_mem}


rule ultra_align:
    input:  reads = config["ROOT_OUT"] + "/data/{dataset}.fa",
            ultra_index = rules.ultra_prep.output.ref_index,
            ref = config["HG38"],
    output: sam = config["ROOT_OUT"] + "/alignments/ultra/{dataset}/reads.sam",
            time_and_mem =  config["ROOT_OUT"] + "/time_and_mem/ultra/{dataset}/aligning_time_and_mem.txt"
    run:
        outfolder = config["ROOT_OUT"] + "/alignments/ultra/{0}/".format(wildcards.dataset)
        shell("/usr/bin/time -v /galaxy/home/ksahlin/prefix/source/torkel/torkel2 align {input.ref} {input.reads}  {outfolder} --min_mem 14 --t 62  2>&1 | tee {output.time_and_mem} ") # 2> {output.time_and_mem}
        shell("mv {outfolder}/torkel.sam {output.sam}")

rule minimap2_index:
    input: ref = config["HG38"]
    output: time_and_mem =  config["ROOT_OUT"] + "/time_and_mem/minimap2/{dataset}/indexing_time_and_mem.txt",
            mm_index =  config["ROOT_OUT"] + "/alignments/minimap2/{dataset}/index.mmi"
    run:
        outfolder = config["ROOT_OUT"] + "/alignments/minimap2/{0}/".format(wildcards.dataset)
        mkdir_p(outfolder)
        time_outfolder = config["ROOT_OUT"] + "/time_and_mem/minimap2/{0}/".format(wildcards.dataset)
        mkdir_p(time_outfolder)

        shell("/usr/bin/time -v  minimap2 -ax splice -k14 -d {output.mm_index} {input.ref} 2> {output.time_and_mem}")


rule minimap2_align:
    input: fastq =  config["ROOT_OUT"] + "/data/{dataset}.fa",
            index = rules. minimap2_index.output.mm_index
    output: time_and_mem =  config["ROOT_OUT"] + "/time_and_mem/minimap2/{dataset}/aligning_time_and_mem.txt",
            sam =  config["ROOT_OUT"] + "/alignments/minimap2/{dataset}/reads.sam"
    run:
        shell("/usr/bin/time -v  minimap2 --eqx -t 62 -ax splice -k14 {input.index} {input.fastq} 1>  {output.sam} 2> {output.time_and_mem} ")


rule desalt_annotation_fix:
    input: gtf_annotation = config["ANNOTATION"] + "/NA12878.gtf"
    output: desalt_gtf_annotation_outfile = config["ROOT_OUT"] + "/alignments/desalt/{dataset}/annotation.info"
    run:
        outfolder = config["ROOT_OUT"] + "/alignments/desalt/{0}/".format(wildcards.dataset)
        mkdir_p(outfolder)
        shell("python /galaxy/home/ksahlin/prefix/source/deSALT/src/Annotation_Load.py {input.gtf_annotation}  {output.desalt_gtf_annotation_outfile}")

rule desalt_index:
    input: ref = config["HG38"]
    output: 
            time_and_mem =  config["ROOT_OUT"] + "/time_and_mem/desalt/{dataset}/indexing_time_and_mem.txt",
            finished_flag =  config["ROOT_OUT"] + "/time_and_mem/desalt/{dataset}/done.txt"
            # desalt_index_folder =  directory(config["ROOT_OUT"] + "/alignments/desalt/{dataset}/index"),
    run:
        outfolder = config["ROOT_OUT"] + "/alignments/desalt/{0}/".format(wildcards.dataset)
        mkdir_p(outfolder)
        time_outfolder = config["ROOT_OUT"] + "/time_and_mem/desalt/{0}/".format(wildcards.dataset)
        mkdir_p(time_outfolder)
        index = config["ROOT_OUT"] + "/alignments/desalt/{0}/index".format(wildcards.dataset)

        # shell("/usr/bin/time -v  /galaxy/home/ksahlin/prefix/source/deSALT/src/./deBGA index {input.ref} {output.desalt_index_folder}") # 2> {output.time_and_mem}")
        shell("/usr/bin/time -v  deSALT index {input.ref} {index} 2>&1 | tee {output.time_and_mem} ") # " 2> {output.time_and_mem}")
        shell("touch  {output.finished_flag} ")

rule desalt_align:
    input: fastq =  config["ROOT_OUT"] + "/data/{dataset}.fq",
            # index = rules.desalt_index.output.desalt_index_folder,
            finished_flag = rules.desalt_index.output.finished_flag
            # desalt_gtf_annotation_outfile = rules.desalt_annotation_fix.output.desalt_gtf_annotation_outfile
    output: sam =  config["ROOT_OUT"] + "/alignments/desalt/{dataset}/reads.sam",
            time_and_mem =  config["ROOT_OUT"] + "/time_and_mem/desalt/{dataset}/aligning_time_and_mem.txt"
    run:
        index = config["ROOT_OUT"] + "/alignments/desalt/{0}/index".format(wildcards.dataset)
        import tempfile
        work_dir = tempfile.mkdtemp()
        tempfile = os.path.join(work_dir, "desalt_temp_prefix")
        shell("/usr/bin/time -v  deSALT aln {index} {input.fastq} -d 10  -s 2 -l 14  -t 48  -o {output.sam} -f {tempfile} 2>&1 | tee {output.time_and_mem} ") 


rule desalt_gtf_align:
    input: fastq =  config["ROOT_OUT"] + "/data/{dataset}.fq",
            # index = rules.desalt_index.output.desalt_index_folder,
            finished_flag = rules.desalt_index.output.finished_flag,
            desalt_gtf_annotation_outfile = rules.desalt_annotation_fix.output.desalt_gtf_annotation_outfile
    output: sam =  config["ROOT_OUT"] + "/alignments/desalt_gtf/{dataset}/reads.sam",
            time_and_mem =  config["ROOT_OUT"] + "/time_and_mem/desalt_gtf/{dataset}/aligning_time_and_mem.txt"
    run:
        index = config["ROOT_OUT"] + "/alignments/desalt/{0}/index".format(wildcards.dataset)
        import tempfile
        work_dir = tempfile.mkdtemp()
        tempfile = os.path.join(work_dir, "desalt_gtf_temp_prefix")
        shell("/usr/bin/time -v  deSALT aln {index} {input.fastq} -d 10  -s 2 -l 14  -t 48 --gtf {input.desalt_gtf_annotation_outfile} -o {output.sam} -f {tempfile}  2>&1 | tee {output.time_and_mem} ") 


rule graphmap2_index:
    input:  ref = config["HG38"],
            fastq =  config["ROOT_OUT"] + "/data/{dataset}.fq",
            gtf_annotation = config["ANNOTATION"] + "/NA12878.gtf",
    output: index =  config["ROOT_OUT"] + "/alignments/graphmap2/{dataset}/index.gmidx",
            time_and_mem =  config["ROOT_OUT"] + "/time_and_mem/graphmap2/{dataset}/aligning_time_and_mem.txt"
    run:
        shell("/usr/bin/time -v  graphmap2 align --index-only --index {output.index}  -x rnaseq -r {input.ref} -d {input.fastq} 2>&1 | tee {output.time_and_mem} ") # 2> {output.time_and_mem}  ")

rule graphmap2_gtf_align:
    input:  ref = config["HG38"],
            fastq =  config["ROOT_OUT"] + "/data/{dataset}.fq",
            index = rules.graphmap2_index.output.index,
            gtf_annotation = config["ANNOTATION"] + "/NA12878.gtf",
    output: sam =  config["ROOT_OUT"] + "/alignments/graphmap2_gtf/{dataset}/reads.sam",
            time_and_mem =  config["ROOT_OUT"] + "/time_and_mem/graphmap2_gtf/{dataset}/aligning_time_and_mem.txt"
    run:
        shell("/usr/bin/time -v  graphmap2 align --index {input.index} --gtf {input.gtf_annotation} --threads 62 -x rnaseq -r {input.ref} -d {input.fastq} -o {output.sam}  2>&1 | tee {output.time_and_mem} ")


rule graphmap2_align:
    input:  ref = config["HG38"],
            fastq =  config["ROOT_OUT"] + "/data/{dataset}.fq",
            index = rules.graphmap2_index.output.index,
            gtf_annotation = config["ANNOTATION"] + "/NA12878.gtf",
    output: sam =  config["ROOT_OUT"] + "/alignments/graphmap2/{dataset}/reads.sam",
            time_and_mem =  config["ROOT_OUT"] + "/time_and_mem/graphmap2/{dataset}/aligning_time_and_mem.txt"
    run:
        shell("/usr/bin/time -v  graphmap2 align --index {input.index} --threads 62 -x rnaseq -r {input.ref} -d {input.fastq} -o {output.sam}  2>&1 | tee {output.time_and_mem} ")


rule evaluate:
    input:  ultra = rules.ultra_align.output.sam,
            minimap2 = rules.minimap2_align.output.sam,
            desalt = rules.desalt_align.output.sam,
            desalt_gtf = rules.desalt_gtf_align.output.sam,
            graphmap2 = rules.graphmap2_align.output.sam,
            graphmap2_gtf = rules.graphmap2_gtf_align.output.sam,
            reads =  config["ROOT_OUT"] + "/data/{dataset}.fa",
            ref =  config["HG38"],
            gtf_annotation = config["ANNOTATION"] + "/NA12878.gtf"  # drosophila v97 gtf annotation
    output: csv_file =  config["ROOT_OUT"] + "/evaluation/{dataset}/results_per_read.csv"
    run:

        eval_dir = config["ROOT_IN"] + "/evaluation/"
        outfolder = config["ROOT_OUT"] + "/evaluation/{0}/".format(wildcards.dataset)  
        mkdir_p(outfolder) 

        if wildcards.dataset == "simulated" or wildcards.dataset == "simulated_nic":
            accessions_map = rules.simulate.output.accessions_map
            # shell("python {eval_dir}/evaluate_simulated_reads.py  --torkel_sam {input.ultra} --mm2_sam {input.minimap2} --desalt_sam {input.desalt} --graphmap2_sam {input.graphmap2}  {input.reads}  \
            #                                                 {input.ref} {input.gtf_annotation} {accessions_map} {outfolder} --load_database")   
            shell("python {eval_dir}/evaluate_simulated_reads.py  --torkel_sam {input.ultra} --mm2_sam {input.minimap2} --desalt_sam {input.desalt} --desalt_gtf_sam {input.desalt_gtf} \
                                                                 --graphmap2_sam {input.graphmap2}  --graphmap2_gtf_sam {input.graphmap2_gtf} {input.reads} \
                                                            {input.ref} {input.gtf_annotation} {accessions_map} {outfolder} --load_database")   

        else:
            # shell("python {eval_dir}/evaluate_splice_annotations.py   --torkel_sam {input.ultra} --mm2_sam {input.minimap2} --desalt_sam {input.desalt} --graphmap2_sam {input.graphmap2}  {input.reads}  \
            #                                                 {input.ref} {input.gtf_annotation} {outfolder} --load_database")
            shell("python {eval_dir}/evaluate_splice_annotations.py   --torkel_sam {input.ultra} --mm2_sam {input.minimap2} --desalt_sam {input.desalt} --desalt_gtf_sam {input.desalt_gtf} \
                                                                    --graphmap2_sam {input.graphmap2} --graphmap2_gtf_sam {input.graphmap2_gtf}  {input.reads}  \
                                                            {input.ref} {input.gtf_annotation} {outfolder} --load_database")


# rule evaluate_real:
#     input: original_reads = rules.subsample.output.subsampled_fastq,
#             corrected_reads = rules.combine_isoncorrect.output.corrected_reads_fastq,
#             original_reads_aligned =  rules.align_original_reads_minimap2.output.original_reads_aligned,
#             corrected_reads_aligned =  rules.align_corrected_reads_minimap2.output.corrected_reads_aligned,
#             clusters_tsv = rules.isONclust.output.clusters,
#             gtf_annotation = config["ANNOTATION"] + "/{dataset}.gtf"  # drosophila v97 gtf annotation
#     output: csv_file =  config["ROOT_OUT"] + "/evaluation_biological/{dataset}/{nr_reads}/results.csv"
#     run:
#         if wildcards.dataset == "SIRV":
#             ref = config["SIRV"]
#         elif wildcards.dataset == "NA12878":
#             ref = config["HG38"]
#         elif wildcards.dataset == "drosophila":
#             ref =  config["drosophila97"]

#         eval_dir = config["ROOT_IN"] + "/scripts/"
#         outfolder = config["ROOT_OUT"] + "/evaluation_biological/{0}/{1}/".format(wildcards.dataset, wildcards.nr_reads)  
#         mkdir_p(outfolder) 
#         if wildcards.dataset == "NA12878":
#             shell("python {eval_dir}/evaluate_real_reads.py  {input.original_reads_aligned}  {input.corrected_reads_aligned} {input.original_reads}  \
#                                                         {input.corrected_reads} {ref} {input.clusters_tsv} {input.gtf_annotation} {outfolder} --load_database")
#         elif wildcards.dataset == "drosophila":
#             shell("python {eval_dir}/evaluate_real_reads.py  {input.original_reads_aligned}  {input.corrected_reads_aligned} {input.original_reads}  \
#                                                         {input.corrected_reads} {ref} {input.clusters_tsv} {input.gtf_annotation} {outfolder}")
#         else:
#             shell("python {eval_dir}/evaluate_real_reads.py  {input.original_reads_aligned}  {input.corrected_reads_aligned} {input.original_reads}  \
#                                                         {input.corrected_reads} {ref} {input.clusters_tsv} {input.gtf_annotation} {outfolder} --infer_genes")



