

"""
    snakemake --keep-going -j 999999 --cluster "sbatch --exclude={cluster.exclude} --mem {cluster.mem} -c {cluster.cpus-per-task} -N {cluster.Nodes}  -t {cluster.runtime} -J {cluster.jobname} --mail-type={cluster.mail_type} --mail-user={cluster.mail}" --cluster-config cluster.json --configfile experiments.json --latency-wait 100 --verbose -n

    
    # BIOLOGICAL

    # Subsample reads from original data


    # running isONclust/isONclust2
    1. going from original reads to clusters
    2. from cluster file to fastq files


    ### Running isONcorrect
    1. From cluster fasta to corrected reads
    2. Merge all corrected read clusters

    ### Run evaluation looking for read error rate againse reference (and eventually splice site classification)

    # SIMULATED

    ### simulation evalautions
    4. Basing exon correction plot with error rate

    5. Join everything to table


    # target rules:

"""

shell.prefix("set -o pipefail; ")
# configfile: "experiments.json"

wildcard_constraints:
    nr_reads="[\d]+",

####################################################
########## standard python functions ###############
####################################################

import re
import os
import errno
import shutil
import glob

def mkdir_p(path):
    print("creating", path)
    try:
        os.makedirs(path)
    except OSError as exc:  # Python >2.5
        if exc.errno == errno.EEXIST and os.path.isdir(path):
            pass
        else:
            raise

rule all:
   input:  config["ROOT_OUT"] + "/evaluation/ont_human/results_per_read.csv",
            config["ROOT_OUT"] + "/evaluation/simulated/results_per_read.csv"


rule biological:
    input: config["ROOT_OUT"] + "/eval_table.csv"


rule simulation:
    input: config["ROOT_OUT"] + "/eval_sim_table.csv"


rule controlled_sim:
    input:  config["ROOT_OUT"] + "/controlled.csv"


rule simulate:
    input:  fasta = config["TRANSCRIPTOME"]
    output: simulated_reads =  config["ROOT_OUT"] + "/data/simulated.fa"
    run:

        inbase= config["ROOT_IN"]
        mkdir_p(config["ROOT_OUT"] + "/data/")

        # python simulate_reads.py ../data/all_transcripts_ENSEMBL.txt ~/tmp/ULTRA/sim_reads_test.fa 100
        shell("python {inbase}/evaluation/simulate_reads.py {input.fasta} {output.simulated_reads} 1000000 --fasta")


rule ultra_prep:
    input:  fastq =  config["ROOT_OUT"] + "/data/{dataset}.fa",
            ref = config["HG38"],
            gtf_annotation = config["ANNOTATION"] + "/NA12878.gtf"

    output: ref_index = config["ROOT_OUT"] + "/alignments/ultra/{dataset}/all_splice_sites_annotations.pickle",
            # time_and_mem =  config["ROOT_OUT"] + "/time_and_mem/ultra/{dataset}/indexing_time_and_mem.txt"
    run:
        outfolder = config["ROOT_OUT"] + "/alignments/ultra/{0}/".format(wildcards.dataset)
        mkdir_p(outfolder)
        time_outfolder = config["ROOT_OUT"] + "/time_and_mem/ultra/{0}/".format(wildcards.dataset)
        mkdir_p(time_outfolder)

        shell("/usr/bin/time -v /galaxy/home/ksahlin/prefix/source/torkel/torkel2 prep_splicing --disable_infer {input.gtf_annotation} {outfolder}")
        shell("/usr/bin/time -v /galaxy/home/ksahlin/prefix/source/torkel/torkel2 prep_seqs {input.ref} {outfolder} --min_mem 14 --mask_threshold 100 ") #2> {output.time_and_mem}


rule ultra_align:
    input:  reads = config["ROOT_OUT"] + "/data/{dataset}.fa",
            ultra_index = rules.ultra_prep.output.ref_index,
            ref = config["HG38"],
    output: sam = config["ROOT_OUT"] + "/alignments/ultra/{dataset}/reads.sam",
            # time_and_mem =  config["ROOT_OUT"] + "/time_and_mem/ultra/{dataset}/aligning_time_and_mem.txt"
    run:
        outfolder = config["ROOT_OUT"] + "/alignments/ultra/{0}/".format(wildcards.dataset)
        shell("/usr/bin/time -v /galaxy/home/ksahlin/prefix/source/torkel/torkel2 align {input.ref} {input.reads}  {outfolder} --min_mem 14 --t 62 ") # 2> {output.time_and_mem}
        shell("mv {outfolder}/torkel.sam {output.sam}")

rule minimap2_index:
    input: ref = config["HG38"]
    output: time_and_mem =  config["ROOT_OUT"] + "/time_and_mem/minimap2/{dataset}/indexing_time_and_mem.txt",
            mm_index =  config["ROOT_OUT"] + "/alignments/minimap2/{dataset}/index.mmi"
    run:
        outfolder = config["ROOT_OUT"] + "/alignments/minimap2/{0}/".format(wildcards.dataset)
        mkdir_p(outfolder)
        time_outfolder = config["ROOT_OUT"] + "/time_and_mem/minimap2/{0}/".format(wildcards.dataset)
        mkdir_p(time_outfolder)

        shell("/usr/bin/time -v  minimap2 -ax splice -k14 -d {output.mm_index} {input.ref} 2> {output.time_and_mem}")


rule minimap2_align:
    input: fastq =  config["ROOT_OUT"] + "/data/{dataset}.fa",
            index = rules. minimap2_index.output.mm_index
    output: time_and_mem =  config["ROOT_OUT"] + "/time_and_mem/minimap2/{dataset}/aligning_time_and_mem.txt",
            sam =  config["ROOT_OUT"] + "/alignments/minimap2/{dataset}/reads.sam"
    run:
        shell("/usr/bin/time -v  minimap2 --eqx -t 32 -ax splice -k14 {input.index} {input.fastq} 1>  {output.sam} 2> {output.time_and_mem} ")


rule evaluate:
    input:  ultra = rules.ultra_align.output.sam,
            minimap2 = rules.minimap2_align.output.sam,
            reads =  config["ROOT_OUT"] + "/data/{dataset}.fa",
            ref =  config["HG38"],
            gtf_annotation = config["ANNOTATION"] + "/NA12878.gtf"  # drosophila v97 gtf annotation
    output: csv_file =  config["ROOT_OUT"] + "/evaluation/{dataset}/results_per_read.csv"
    run:

        eval_dir = config["ROOT_IN"] + "/evaluation/"
        outfolder = config["ROOT_OUT"] + "/evaluation/{0}/".format(wildcards.dataset)  
        mkdir_p(outfolder) 
        shell("python {eval_dir}/evaluate_alignments.py  {input.ultra}  {input.minimap2} {input.reads}  \
                                                        {input.ref} {input.gtf_annotation} {outfolder} --load_database")


# rule evaluate_real:
#     input: original_reads = rules.subsample.output.subsampled_fastq,
#             corrected_reads = rules.combine_isoncorrect.output.corrected_reads_fastq,
#             original_reads_aligned =  rules.align_original_reads_minimap2.output.original_reads_aligned,
#             corrected_reads_aligned =  rules.align_corrected_reads_minimap2.output.corrected_reads_aligned,
#             clusters_tsv = rules.isONclust.output.clusters,
#             gtf_annotation = config["ANNOTATION"] + "/{dataset}.gtf"  # drosophila v97 gtf annotation
#     output: csv_file =  config["ROOT_OUT"] + "/evaluation_biological/{dataset}/{nr_reads}/results.csv"
#     run:
#         if wildcards.dataset == "SIRV":
#             ref = config["SIRV"]
#         elif wildcards.dataset == "NA12878":
#             ref = config["HG38"]
#         elif wildcards.dataset == "drosophila":
#             ref =  config["drosophila97"]

#         eval_dir = config["ROOT_IN"] + "/scripts/"
#         outfolder = config["ROOT_OUT"] + "/evaluation_biological/{0}/{1}/".format(wildcards.dataset, wildcards.nr_reads)  
#         mkdir_p(outfolder) 
#         if wildcards.dataset == "NA12878":
#             shell("python {eval_dir}/evaluate_real_reads.py  {input.original_reads_aligned}  {input.corrected_reads_aligned} {input.original_reads}  \
#                                                         {input.corrected_reads} {ref} {input.clusters_tsv} {input.gtf_annotation} {outfolder} --load_database")
#         elif wildcards.dataset == "drosophila":
#             shell("python {eval_dir}/evaluate_real_reads.py  {input.original_reads_aligned}  {input.corrected_reads_aligned} {input.original_reads}  \
#                                                         {input.corrected_reads} {ref} {input.clusters_tsv} {input.gtf_annotation} {outfolder}")
#         else:
#             shell("python {eval_dir}/evaluate_real_reads.py  {input.original_reads_aligned}  {input.corrected_reads_aligned} {input.original_reads}  \
#                                                         {input.corrected_reads} {ref} {input.clusters_tsv} {input.gtf_annotation} {outfolder} --infer_genes")



